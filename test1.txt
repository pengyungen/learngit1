很高兴我又开始学习git！哈哈哈
it's fun!
每天学习一点
创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录 mkdir learngit，然后cd learngit，pwd查看当前目录。git init命令把这个目录变成Git可以管理的仓库，git add readme.txt告诉Git，把文件添加到仓库，git commit -m "wrote a readme file"把文件提交到仓库

git tracks changes.
stage is 暂存区
只能commit 做了修改的
learngit1目录下为工作区，然后是暂存区（add），然后是本地库（git）。.git文件是自动生成，管理仓库
git checkout -- file:让文件回到最近一次git commit或git add前的状态
git reset HEAD file可以把暂存区的修改撤销掉
不但改错了东西，还从暂存区提交到了版本库：版本回退，可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程
rm test.txt删除工作区（work directory）即learngit1里的东西,相当于直接手动删除文件
git rm test.txt删除本地库里的，然后commit
git diff readme.txt查看difference
git reset --hard HEAD^版本回退
git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别
工作区文件删错了，若版本库里有（已提交或暂存），git checkout -- test.txt可以恢复
从版本库中删除文件，git rm，并且git commit-m "remove test.txt"
git config --list查看配置信息

GitHub提供Git本地仓库托管服务

本地Git仓库和GitHub仓库之间的传输是通过SSH加密
为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。
GitHub允许你添加多个Key。假定你有若干电脑，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。
在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。或者自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人是看不见的。

关联一个远程库git remote add origin git@github.com:pengyungen/learngit.git
git push -u origin master第一次推送master分支的所有内容；git push origin master推送最新修改
从远程库克隆git clone git@github.com:michaelliao/gitskills.git（若之前还没有创建本地库，可以先创建远程库，从远程库克隆，然后用cd gitskills来进入到此工作目录，ls查看目录下文件）
GitHub给出的地址不止一个，还可以用git(https)://github.com/michaelliao/gitskills.git,Git支持多种协议，默认的git://使用ssh

创建一个属于自己的分支，别人看不到,想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，不影响别人工作.
master主分支，可创建其他分支如dev，若让HEAD指向dev，表示当前分支在dev上，此时对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：
git checkout -b dev创建并切换（git branch dev+git checkout dev），git branch查看当前分支，git checkout master切换回master分支，git merge dev合并指定分支到当前分支（master），
1.这种合并方式是直接让master指针指向dev的当前提交（缺点：丢失分支信息），git branch -d dev删除dev分支。git branch命令会列出所有分支，当前分支前面会标一个*号
合并分支2：解决冲突：master分支和dev分支各自都分别有新的提交,此时执行合并，冲突，（git diff test1.txt查看两个分支内容不同之处）然后再把.txt文件修改，再提交即可合并。
git log --graph --pretty=oneline --abbrev-commit可以看到分支合并图

分支管理策略：master分支是稳定的，也就是仅用来发布新版本，平时不能在上面干活；干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本，你和你的小伙伴们每个人都有自己的分支，时不时地往dev分支上合并就可以了。
3.git merge --no-ff -m "merge with no-ff" dev表示禁用合并方式1，即不是直接让master指针指向dev的当前提交，这样可以保证master分支内容始终没问题（不会经常提交不完整内容），dev分支可以随时提交，即在dev上干活。
合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并

别的地方有bug需要解决，但当前工作只进行到一半，还不能提交，git stash可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作，（创建别的分支来解决bug）git stash list命令查看stash内容，git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；git stash pop，恢复的同时把stash内容也删了。

git remote -v显示远程库信息，git push origin dev把本地的dev分支推送。
多人协作时，大家都会往master和dev分支上推送各自的修改，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆


git remote -v显示远程库信息，git push origin dev把本地的dev分支推送。
多人协作时，大家都会往master和dev分支上推送各自的修改，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆。如果推送失败，先用git pull抓取远程的新提交，git pull提示“no tracking information，用git branch --set-upstream branch-name origin/branch-name建立本地分支和远程分支链接关系。

在Git中打标签，先切换到需要打标签的分支上，git tag v1.0，git tag查看所有标签，默认标签是打在最新提交的commit上的，git log --pretty=oneline --abbrev-commit找到历史提交的commit id。如：git tag v0.9 6224937（历史 id），git show v0.9查看标签信息。git tag -a v0.1 -m "version 0.1 released" 3628164，-a指定标签名，-m指定说明文字。